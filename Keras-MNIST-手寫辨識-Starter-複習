# 如何知道有多少數據
from keras import datasets
from keras.utils import to_categorical
from keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt

# tuple (a, b)
# list  [a, b]
# dict  {'a':b}

#len(mnist.load_data()[1][1]) 
mnist.load_data()[1][1].shape

# 數據是28 * 28 = 784
(X_train, y_train), (X_test, y_test) = mnist.load_data()
X_train.shape, y_train.shape, X_test.shape, y_test.shape

# 第一張圖片
X_train[0].shape

# 畫一張
%matplotlib inline
plt.figure(figsize=(3/4, 3/4))
plt.imshow(X_train[0], cmap='gray_r')
plt.axis('off')
plt.show()

X_test.shape
# data pre-processing
X_train, X_test = X_train.astype(np.float32).reshape(60000, 784), X_test.astype(np.float32).reshape(10000, 784)
# one_hot encoding
y_train_oh, y_test_oh = to_categorical(y_train), to_categorical(y_test) 

# '''
# alueError: Colormap xxx is not recognized. Possible values are: 

# build model Sequential = 底座 , Dense : 神經層 , optimizers 找出所有參數的最小誤差(loss) adam sgd 
# activation feedward 計算過程 判斷神經是否可以從上一層 到 下一層  relu sigmoid softmax
# 60000 : 筆數 , (28, 28) :每一張相片(row,col), 784 : flatten of (28, 28)
# 60000 : 攸關到 batch_size 產生要訓練幾次
# 784   : input layer features(dim)
# 1000  : 1st hidden layer units 
# 500   : 2nd hidden layer units
# 10    : output layer units
# epochs: 針對那全部的六萬(60000)每一次批次，要循環幾次，訓練上述的參數 1,290,510
from keras.models import Sequential
from keras.layers import Dense
from keras import optimizers
model = Sequential()
model.add( Dense(units=1000, activation='relu', input_shape=(784,) ) )
model.add( Dense(units=500, activation='relu') )
model.add( Dense(units=10, activation='softmax') )
model.summary()

# train model 
# ValueError: Error when checking target: expected dense_3 to have 2 dimensions
# but got array with shape (60000, 10, 2, 2)
# ValueError: Error when checking target: expected dense_6 to have shape (10,) but got array with shape (1,)

model.compile(optimizer=optimizers.Adam(lr=0.01), loss='categorical_crossentropy', metrics=['accuracy'] )
history = model.fit(X_train, y_train_oh, validation_split=0.1, epochs=10, verbose=1, batch_size= 1000)

# top 10 
# 請你找一下那些數字是錯誤 slicing 
index_error = np.argmax(y_pred, axis=1) != np.argmax(y_test_oh, axis=1)

X_error      =  X_test[ index_error ]
y_error      =  y_test_oh[ index_error ]
y_error_pred =  y_pred[ index_error ]

print('Total error amount is {}'.format(X_error.shape[0]))

# Plot for top 10 [:10]
for i in range(10):
    plt.figure(figsize=(1,1))
    plt.title('GT:{} --> Pred:{}'.format(np.argmax(y_error[i]), np.argmax(y_error_pred[i])) )
    plt.imshow(X_error[i].reshape(28,28), cmap='gray' )
    plt.axis('off')
    plt.show()
